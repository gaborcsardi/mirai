% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{mirai_map}
\alias{mirai_map}
\title{mirai Map}
\usage{
mirai_map(.x, .f, ..., .args = list(), .compute = "default")
}
\arguments{
\item{.x}{a list or atomic vector.}

\item{.f}{a function to be applied to each element of \code{.x}.}

\item{...}{optional constant arguments to \code{.f}.}

\item{.args}{optional constant arguments to \code{.f}, provided as a list.}

\item{.compute}{[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).}
}
\value{
A \sQuote{mirai_map} object.
}
\description{
Asynchronous parallel / distributed map of a function over a list or vector
    using \pkg{mirai}.
}
\details{
Sends each application of function \code{.f} on an element of
    \code{.x} for computation in a separate \code{\link{mirai}} call.

    This simple and transparent behaviour is designed to make full use of
    \pkg{mirai} scheduling to minimise overall execution time.

    Facilitates recovery from partial failure by returning all
    \sQuote{miraiError} / \sQuote{errorValue} as the case may be, thus
    allowing only the failures to be re-run.

    Note: daemons are assumed to have been previously set, otherwise new
    ephemeral daemons will be created for each computation.
}
\section{Results}{


    To collect the results of the map operation, use \code{x[]} on a
    mirai_map \sQuote{x}. This will wait for all asynchronous
    operations to complete if still in progress (blocking, although
    user-interruptible).
}

\examples{
if (interactive()) {
# Only run examples in interactive R sessions

with(
  daemons(3, dispatcher = FALSE),
  mirai_map(1:3, rnorm, mean = 20, .args = list(sd = 2))[]
)

# progress indicator counts up to 4 seconds
with(
  daemons(4, dispatcher = FALSE),
  mirai_map(1:4, Sys.sleep)[]
)

# creates 3 ephemeral daemons as daemons not set
# second element returns a 'miraiError'
mirai_map(list(a = 1, b = "a", c = 3), sum)[]

ml <- mirai_map(c(a = 2, b = 3, c = 4), rnorm)
ml
ml[]

}

}

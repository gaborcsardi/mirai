% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{mmap}
\alias{mmap}
\alias{mwalk}
\alias{mcollect}
\title{mirai Map Functions}
\usage{
mmap(
  .x,
  .f,
  ...,
  .args = list(),
  .progress = FALSE,
  .stop = FALSE,
  .compute = "default"
)

mwalk(.x, .f, ..., .args = list(), .compute = "default")

mcollect(x)
}
\arguments{
\item{.x}{a list or atomic vector.}

\item{.f}{a function to be applied to each element of \code{.x}.}

\item{...}{optional arguments to \code{.f}.}

\item{.args}{optional arguments to \code{.f} provided as a list.}

\item{.progress}{[default FALSE] if TRUE, reports progress via a simple text
progress indicator to \sQuote{stderr}.}

\item{.stop}{[default FALSE] errors are returned as \sQuote{miraiError} /
\sQuote{errorValue} as the case may be, allowing recovery from partial
failure. If TRUE, performs early stopping as soon as an error is
encountered, with remaining computations aborted.}

\item{.compute}{[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).}

\item{x}{a list of \sQuote{mirai} objects.}
}
\value{
For \code{mmap} and \code{mwalk}: a list, the same length as
    \code{.x}, preserving names.

For \code{mcollect}: a list, the same length as \code{x}, preserving
    names.
}
\description{
\code{mmap} maps a function over a list or vector using \pkg{mirai}.

\code{mwalk} walk a function over a list or vector using \pkg{mirai} for the
    side-effects.

\code{mcollect} waits for and collects the data from \code{mwalk} or a list
    of \sQuote{mirai} objects.
}
\section{mmap}{


    This function sends each application of \code{.f} on an element of
    \code{.x} for computation in a separate \code{\link{mirai}} call, and
    waits for completion.

    Designed to facilitate recovery from partial failure by returning all
    results by default, allowing only the failures to be re-run.

    Alternatively, there is the option for early stopping, which stops at the
    first failure and aborts all remaining computations.

    This function does not perform chunking (assigning multiple elements of
    \code{.x} in batches), and is hence particularly suited to lengthy
    computations or those which have variable or unpredicatable compute times
    over the indices, where it can be optimal to rely on \pkg{mirai}
    scheduling.

    Note: daemons should generally be set prior to calling this function,
    otherwise ephemeral daemons will be created for each computation.
}

\section{mwalk}{


    This function sends each application of \code{.f} on an element of
    \code{.x} for computation in a separate \code{\link{mirai}} call. It does
    not wait for completion.

    Whilst this function is designed primarily to enact side effects, it may
    also be used as an asynchronous map function by returning a list of
    \sQuote{mirai}, and their values may be collected using \code{mcollect}.

    This function does not perform chunking (assigning multiple elements of
    \code{.x} in batches), and is hence particularly suited to lengthy
    computations or those which have variable or unpredicatable compute times
    over the indices, where it can be optimal to rely on \pkg{mirai}
    scheduling.

    Note: daemons should generally be set prior to calling this function,
    otherwise ephemeral daemons will be created for each computation.
}

\examples{
if (interactive()) {
# Only run examples in interactive R sessions

with(
  daemons(3, dispatcher = FALSE),
  mmap(1:3, rnorm, mean = 20, .args = list(sd = 2))
)

# progress indicator counts up to 4 seconds
with(daemons(4, dispatcher = FALSE), mmap(1:4, Sys.sleep, .progress = TRUE))

# creates 3 ephemeral daemons as daemons not set
# second element returns a 'miraiError'
mmap(list(a = 1, b = "a", c = 3), sum)

ml <- mwalk(c(a = 2, b = 3, c = 4), rnorm, mean = 20, .args = list(sd = 2))
ml
mcollect(ml)

}

}

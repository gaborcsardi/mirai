% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{mmap}
\alias{mmap}
\alias{mcollect}
\title{mirai Map / Collect}
\usage{
mmap(.x, .f, ..., .args = list(), .compute = "default")

mcollect(x, interrupt = TRUE, progress = FALSE, stop = FALSE)
}
\arguments{
\item{.x}{a list or atomic vector.}

\item{.f}{a function to be applied to each element of \code{.x}.}

\item{...}{optional constant arguments to \code{.f}.}

\item{.args}{optional constant arguments to \code{.f}, provided as a list.}

\item{.compute}{[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).}

\item{x}{a list of \sQuote{mirai} objects.}

\item{interrupt}{[default TRUE] logical value, whether or not to allow
user interrupts.}

\item{progress}{[default FALSE] if TRUE, reports progress via a simple text
progress indicator.}

\item{stop}{[default FALSE] errors are returned as \sQuote{miraiError} /
\sQuote{errorValue} as the case may be, allowing recovery from partial
failure. If TRUE, performs early stopping as soon as an error is
encountered, with remaining in-progress computations aborted.}
}
\value{
For \code{mmap}: a list of \sQuote{mirai} objects, the same length as
    \code{.x}, preserving names.

For \code{mcollect}: a list, the same length as \sQuote{x},
    preserving names.
}
\description{
Asynchronous parallel / distributed map functions. \cr \cr \code{mmap} maps
    a function over a list or vector, returning a list of \sQuote{mirai}
    objects.

\code{mcollect} collects the results from \code{mmap} or any list of
    \sQuote{mirai} objects, waiting for resolution if still in progress.
}
\section{mmap}{


    Sends each application of function \code{.f} on an element of \code{.x}
    for computation in a separate \code{\link{mirai}} call.

    Chunking (processing multiple elements of \code{.x} in batches) is not
    performed. For lengthy computations, or those with varying or
    unpredictable compute times over the indices, it can be optimal to rely
    on \pkg{mirai} scheduling instead.

    Designed to facilitate recovery from partial failure by returning all
    \sQuote{miraiError} / \sQuote{errorValue} as the case may be, thus
    allowing only the failures to be re-run.

    Note: daemons are assumed to have been previously set, otherwise new
    ephemeral daemons will be created for each computation.
}

\section{mcollect}{


    This function will wait for all asynchronous operation(s) to
    complete if still in progress (blocking).

    Optionally shows a simple text progress indicator.

    Allows for early stopping, which stops at the first failure and aborts
    all remaining in-progress computations.
}

\examples{
if (interactive()) {
# Only run examples in interactive R sessions

with(
  daemons(3, dispatcher = FALSE),
  mcollect(mmap(1:3, rnorm, mean = 20, .args = list(sd = 2)))
)

# progress indicator counts up to 4 seconds
with(
  daemons(4, dispatcher = FALSE),
  mcollect(mmap(1:4, Sys.sleep), progress = TRUE)
)

# creates 3 ephemeral daemons as daemons not set
# second element returns a 'miraiError'
mcollect(mmap(list(a = 1, b = "a", c = 3), sum))

ml <- mmap(c(a = 2, b = 3, c = 4), rnorm, mean = 20, .args = list(sd = 2))
ml

mcollect(ml)

}

}

# Copyright (C) 2023 Hibiki AI Limited <info@hibiki-ai.com>
#
# This file is part of mirai.
#
# mirai is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# mirai is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# mirai. If not, see <https://www.gnu.org/licenses/>.

# mirai ------------------------------------------------------------------------

#' Launch Daemon
#'
#' \code{launch_local} spawns a new background \code{Rscript} process calling
#'     \code{\link{daemon}} with the specified arguments. May be used to
#'     re-launch daemons that have timed out on the local machine.
#'
#' @inheritParams saisei
#' @param url the character host URL or vector of host URLs, including the port
#'     to connect to (and optionally for websockets, a path), e.g.
#'     tcp://192.168.0.2:5555' or 'ws://192.168.0.2:5555/path'
#'
#'     \strong{or} integer index value, or vector of index values, of the
#'     dispatcher URLs, or 1L for the host URL (when not using dispatcher).
#' @param ... (optional) additional arguments passed to \code{\link{daemon}}
#'     (see 'additional arguments' section below).
#' @param tls [default NULL] required for secure TLS connections over tls+tcp or
#'     wss. Zero-configuration TLS certificates generated by \code{\link{daemons}}
#'     are automatically passed to the daemon, without requiring to be specified
#'     here. Otherwise, supply \strong{either} the character path to a file
#'     containing X.509 certificate(s) in PEM format, comprising the certificate
#'     authority certificate chain, \strong{or} a length 2 character vector
#'     comprising [i] the certificate authority certificate chain and [ii] the
#'     empty character ''.
#'
#' @return For \strong{launch_local}: Invisible NULL.
#'
#' @section Additional arguments:
#'
#'     Additional arguments may be specified as part of '\code{...}' to be
#'     passed on to \code{\link{daemon}}:
#'
#'     \itemize{
#'     \item{\strong{asyncdial}} {[default FALSE] whether to perform dials
#'     asynchronously. The default FALSE will error if a connection is not
#'     immediately possible (e.g. \code{\link{daemons}} has yet to be called, or
#'     the specified port is not open etc.). Specifying TRUE continues retrying
#'     (indefinitely) if not immediately successful, which is more resilient but
#'     can mask potential connection issues.}
#'     \item{\strong{output}} {[default FALSE] Specify as TRUE to provide
#'     redirection of output (stdout and stderr) from the daemon to the host
#'     process. This option is only applicable for local daemons when not using
#'     dispatcher.}
#'     }
#'
#' @details If daemons have been set, the generated command will automatically
#'     contain the argument 'rs' specifying the length 7 L'Ecuyer-CMRG random
#'     seed supplied to the daemon. The values will be different each time the
#'     function is called.
#'
#' @examples
#' if (interactive()) {
#' # Only run examples in interactive R sessions
#'
#' daemons(url = "ws://[::1]:0", dispatcher = FALSE)
#' status()
#' launch_local(status()$daemons, maxtasks = 10L)
#' launch_remote(1L, maxtasks = 10L)
#' Sys.sleep(1)
#' status()
#' daemons(0)
#'
#' daemons(n = 2L, url = "tls+tcp://[::1]:0")
#' status()
#' launch_local(1:2, idletime = 60000L, timerstart = 1L)
#' launch_remote(1:2, idletime = 60000L, timerstart = 1L)
#' Sys.sleep(1)
#' status()
#' daemons(0)
#'
#' }
#'
#' @export
#'
launch_local <- function(url, ..., tls = NULL, .compute = "default") {

  envir <- ..[[.compute]]
  dots <- parse_dots(...)
  if (is.null(tls)) tls <- envir[["tls"]]
  url <- process_url(url, .compute = .compute)
  for (u in url)
    if (length(envir[["stream"]]))
      launch_daemon(u, dots, next_stream(envir), tls = tls) else
        launch_daemon(u, dots, tls = tls)

}

#' Launch Daemon
#'
#' \code{launch_remote} returns the shell command for launching daemons as a
#'     character vector. If 'command' is specified, this is executed with the
#'     arguments in 'args' to effect the daemon launch on the remote machine.
#'
#' @param command (optional) the command used to effect the daemon launch on the
#'     remote machine as a character string (e.g. \code{'ssh'}).
#' @param args (optional) arguments passed to 'command', as a character vector
#'     that must include \code{"."} as an element, which will be substituted
#'     for the daemon launch command. Alternatively, a list of character
#'     vectors, such as those produced by \code{\link{ssh_args}}, a convenience
#'     function for constructing valid SSH arguments.
#' @param rscript [default 'Rscript'] name / path of the Rscript executable on
#'     the remote machine. The default assumes 'Rscript' is on the executable
#'     search path. Prepend the full path if necessary. If launching on Windows,
#'     'Rscript' should be replaced with 'Rscript.exe'.
#'
#' @return For \strong{launch_remote}: A character vector of daemon launch
#'     commands the same length as 'url'. For manual deployment, unescape the
#'     double quotes around the call to \code{"mirai::daemons()"}.
#'
#' @rdname launch_local
#' @export
#'
launch_remote <- function(url, ..., tls = NULL, .compute = "default",
                          command = NULL, args = c("", "."), rscript = "Rscript") {

  envir <- ..[[.compute]]
  dots <- parse_dots(...)
  if (is.null(tls)) tls <- envir[["tls"]]
  ulen <- length(url)
  url <- process_url(url, .compute = .compute)

  if (length(command) && is.list(args)) {

    if (length(args) == 1L) {
      args <- args[[1L]]

    } else if (ulen == 1L || ulen == length(args)) {

      arglen <- length(args)
      cmds <- character(arglen)
      for (i in seq_along(args))
        cmds[i] <- sprintf("%s -e %s", rscript, if (length(envir[["stream"]]))
          write_args(list(url[min(i, ulen)], dots, next_stream(envir)), tls = tls) else
            write_args(list(url[min(i, ulen)], dots), tls = tls))

      for (i in seq_along(args))
        system2(command = command, args = `[<-`(args[[i]], find_dot(args[[i]]), shQuote(cmds[i])), wait = FALSE)

      return(cmds)

    } else {
      stop(.messages[["arglen"]])
    }

  }

  cmds <- character(ulen)
  for (i in seq_along(url))
    cmds[i] <- sprintf("%s -e %s", rscript, if (length(envir[["stream"]]))
      write_args(list(url[i], dots, next_stream(envir)), tls = tls) else
        write_args(list(url[i], dots), tls = tls))

  if (length(command))
    for (cmd in cmds)
      system2(command = command, args = `[<-`(args, find_dot(args), shQuote(cmd)), wait = FALSE)

  cmds

}

#' SSH Arguments Constructor
#'
#' Return value may be supplied directly to the 'args' argument of
#'     \code{\link{launch_remote}} or \code{\link{make_cluster}}.
#'
#' @param names a character vector of hostnames or IP addresses of the remote
#'     machines on which to launch daemons (nodes), e.g.
#'     \code{c('10.75.37.90', 'nodename')}.
#' @param port [default 22] numeric port number on which to connect.
#' @param timeout [default 5] maximum time allowed for connection setup in seconds.
#' @param tunnel [default FALSE] logical value whether to use SSH reverse
#'     tunnelling. If TRUE, a tunnel is created between the same local and
#'     remote port specified as part of 'url' of the function where this is
#'     being used as an argument. 'url' in this case must be either 'localhost'
#'     or '127.0.0.1'. This is as the host listens at 'url' on the local machine,
#'     whilst the nodes dial into the same 'url' on the remote machine, and the
#'     SSH tunnel connects both ends.
#'
#' @return A list of character vectors the same length as 'names'.
#'
#' @details By default, uses the SSH flags -f to background the SSH process and
#'     -T to not require a tty for efficiency.
#'
#'     For simplicity, this SSH tunnelling implementation uses the same port
#'     on both the side of the host and that of the corresponding node.
#'
#' @note This function only returns the relevant SSH arguments; 'command' must
#'     also be specified as 'ssh' or the path to the SSH application.
#'
#' @section SSH Direct Connection:
#'
#'     The simplest use of SSH is to execute the daemon launch command on a
#'     remote machine, for it to dial back to the host / dispatcher URL. The
#'     relevant port on the host must be open to inbound connections from the
#'     remote machine.
#'
#'     The following shows an example for \code{\link{make_cluster}}, and is
#'     equally valid for the same arguments in \code{\link{launch_remote}}.
#'
#'     \verb{
#'     make_cluster(
#'       # host URL accessible to nodes
#'       url = "tcp://10.75.37.40:5555",
#'       # launch nodes using SSH
#'       command = "ssh",
#'       # node IP / hostnames to connect to with custom port number
#'       args = ssh_args(
#'         names = c("10.75.37.90", "10.75.37.91"),
#'         port = 222,
#'         timeout = 1
#'       )
#'     )
#'     }
#'
#' @section SSH Tunnelling:
#'
#'     Use of SSH tunnelling provides a convenient way to launch remote nodes
#'     without requiring the remote machine to be able to access the host.
#'     Often firewall configurations or security policies may prevent opening a
#'     port to accept outside connections.
#'
#'     In these cases SSH tunnelling offers a solution by creating a tunnel once
#'     the initial SSH connection is made. The tunnel is created between
#'     \code{localhost:port} or equivalently \code{127.0.0.1:port} on each machine.
#'     This means that the host should listen to \code{localhost:port} and the
#'     nodes should each dial into \code{localhost:port} on their own respective
#'     machines.
#'
#'     The following is an example for \code{\link{make_cluster}}, and is
#'     equally valid for the same arguments in \code{\link{launch_remote}}.
#'
#'     \verb{
#'     make_cluster(
#'       # use 'localhost' or '127.0.0.1' with a port available on all machines
#'       url = "tcp://localhost:5555",
#'       # launch nodes using SSH
#'       command = "ssh",
#'       # launch 2 nodes on the remote machine with SSH tunnelling
#'       args = ssh_args(
#'         names = c("10.75.37.90", "10.75.37.90"),
#'         timeout = 1,
#'         tunnel = TRUE
#'       )
#'     )
#'     }
#'
#' @examples
#' ssh_args(names = c("10.75.37.90", "nodename"), port = 222, timeout = 10)
#'
#' @export
#'
ssh_args <- function(names, port = 22, timeout = 5, tunnel = FALSE) {

  if (tunnel) {
    url <- dynGet("url", ifnotfound = stop(.messages[["correct_context"]]))
    purl <- lapply(url, parse_check_local_url)
    plen <- length(purl)
  }

  nlen <- length(names)
  args <- vector(mode = "list", length = if (tunnel) max(nlen, plen) else nlen)

  for (i in seq_along(args)) {
    args[[i]] <- c(
      if (tunnel) sprintf("-R %s:%s", purl[[min(i, plen)]][["port"]], purl[[min(i, plen)]][["host"]]),
      sprintf("-o ConnectTimeout=%s -fTp", as.character(timeout)),
      as.character(port),
      names[[min(i, nlen)]],
      "."
    )
  }

  args

}
